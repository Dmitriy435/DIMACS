

# This file was *autogenerated* from the file cuspidal_reps.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)# Preliminaries

# Field and general linear group
q = _sage_const_3 
K = GF(q)
G = GL(_sage_const_2 , K)

# Borel subgroup
a = K.zeta()
MS = MatrixSpace(K, _sage_const_2 )
gens = [MS([[_sage_const_1 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ]]),MS([[a,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ]]), MS([[_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,a]])]
B = G.subgroup(gens)

# U subgroup
gens = [MS([[_sage_const_1 ,x],[_sage_const_0 ,_sage_const_1 ]]) for x in K]
U = G.subgroup(gens)

# Creating vector space for induced rep
dim = (q+_sage_const_1 ) * (q-_sage_const_1 )**_sage_const_2 
V = VectorSpace(QQbar, dim)


# The chosen coset representations of U\G
cosetRepsB = []
for x in K:
    rep = G(MS([[_sage_const_1 ,_sage_const_0 ],[-x,_sage_const_1 ]]))
    cosetRepsB.append(rep)
rep = G(MS([[_sage_const_0 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ]]))
cosetRepsB.append(rep)

cosetRepsD = []
for x in K:
    if x != _sage_const_0 :
        for y in K:
            if y != _sage_const_0 :
                rep = G(MS([[_sage_const_1  / x, _sage_const_0 ],[_sage_const_0 , _sage_const_1  / y]]))
                cosetRepsD.append(rep)

repToIndex = {}
index = _sage_const_0 

cosetReps = []
for gRep in cosetRepsB:
    for dRep in cosetRepsD:
        rep = dRep * gRep
        cosetReps.append(rep)
        repToIndex[rep] = index
        index = index + _sage_const_1 
#print(cosetReps)
print(len(cosetReps))









ct = U.character_table()
#print(ct)

#for chi in ct:
#    print(U.character(chi).induct(G).values())
# Notice this induced rep same for all non-unit chars!!!

chi = U.character(ct[_sage_const_1 ])
print(chi.values())






# NEED TO CHANGE THIS!!!

# Takes in element g from G and returns the corresponding representative in U\G
def toRepresentative(g):
    gRep = -_sage_const_1 
    if g.inverse().matrix()[_sage_const_0 ][_sage_const_0 ] == _sage_const_0 :
        gRep = G(MS([[_sage_const_0 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ]]))
    else:
        x = (K.one() / g.inverse().matrix()[_sage_const_0 ][_sage_const_0 ]) * g.inverse().matrix()[_sage_const_1 ][_sage_const_0 ]
        gRep = G(MS([[_sage_const_1 ,_sage_const_0 ],[x,_sage_const_1 ]]))

    b = gRep.inverse() * g.inverse()
    d = G(MS([[b.matrix()[_sage_const_0 ][_sage_const_0 ], _sage_const_0 ], [_sage_const_0 , b.matrix()[_sage_const_1 ][_sage_const_1 ]]]))

    u = gRep * d
    return u.inverse()
# Constant time



# Gives the G action result of group element g from G onto vector v from V
# Uses globally defined character chi
# Uses globally defined vector space V
def gAction(g, vec):
    newVec = V([_sage_const_0 ] * dim)
    for i in range(_sage_const_0 , dim):
        if vec[i] == _sage_const_0 :
            continue
        newRep = toRepresentative(cosetReps[i] * g.inverse())
        #print(newRep)
        u = cosetReps[i] * g.inverse() * newRep.inverse()
        
        newIndex = repToIndex[newRep]

        newVec[newIndex] = newVec[newIndex] + chi(u.inverse()) * vec[i]
        #print(chi(u.inverse()) * vec[i])

    return newVec
# Linear time



g = G(MS([[_sage_const_1 , _sage_const_2 ], [_sage_const_1 , _sage_const_1 ]]))
print(g)

print(toRepresentative(g))
print(g * toRepresentative(g).inverse())

vec = V.random_element()

print(vec)
print(gAction(g, vec))

